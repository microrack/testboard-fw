<!DOCTYPE html>
<html>
<head>
    <title>Testboard Configuration Editor</title>
    <meta charset="utf-8">
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1200px;
            margin: 5px auto;
            padding: 5px;
            background-color: #f5f5f5;
        }
        .action-buttons {
            display: flex;
            gap: 3px;
            margin-left: auto;
        }
        .action-buttons {
            display: flex;
            gap: 3px;
            margin-left: auto;
        }
        .btn {
            padding: 6px 10px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            transition: background-color 0.3s;
            min-width: 80px;
        }
        .btn-primary { background-color: #007bff; color: white; }
        .btn-primary:hover { background-color: #0056b3; }
        .btn-success { background-color: #28a745; color: white; }
        .btn-success:hover { background-color: #1e7e34; }
        .btn-warning { background-color: #ffc107; color: black; }
        .btn-warning:hover { background-color: #e0a800; }
        .btn-danger { background-color: #dc3545; color: white; }
        .btn-danger:hover { background-color: #c82333; }
        .btn-secondary { background-color: #6c757d; color: white; }
        .btn-secondary:hover { background-color: #545b62; }
        
        .file-input {
            display: none;
        }
        
        .module-section {
            margin-bottom: 5px;
            padding: 5px;
            border: 1px solid #dee2e6;
            border-radius: 3px;
        }
        
        .module-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 5px;
        }
        
        .module-header h3 {
            margin: 0;
            color: #495057;
        }
        
        .module-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .module-selector input, .module-selector select {
            padding: 4px 6px;
            border: 1px solid #ced4da;
            border-radius: 3px;
            font-size: 12px;
        }
        
        .edit-mode-tabs {
            display: flex;
            gap: 2px;
        }
        
        .edit-mode-tabs .btn {
            padding: 4px 8px;
            font-size: 11px;
            min-width: auto;
        }
        
        .edit-mode-tabs .btn.active {
            background-color: #007bff;
            color: white;
        }
        
        .edit-mode-tabs .btn:not(.active) {
            background-color: #6c757d;
            color: white;
        }
        
        .aliases-section {
            margin-bottom: 10px;
            padding: 8px;
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 3px;
        }
        
        .aliases-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
            font-weight: bold;
            color: #495057;
            cursor: pointer;
            user-select: none;
        }
        
        .aliases-toggle {
            font-size: 14px;
            transition: transform 0.3s;
        }
        
        .aliases-toggle.collapsed {
            transform: rotate(-90deg);
        }
        
        .aliases-content {
            transition: max-height 0.3s ease-out;
            overflow: hidden;
            max-height: 0;
        }
        
        .aliases-content.expanded {
            max-height: 500px;
        }
        
        .aliases-list {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }
        
        .alias-line {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 3px;
            background-color: white;
            border: 1px solid #dee2e6;
            border-radius: 2px;
        }
        
        .alias-line-number {
            min-width: 25px;
            font-size: 11px;
            color: #6c757d;
            text-align: center;
        }
        
        .alias-name-input {
            width: 120px;
            padding: 2px 4px;
            border: 1px solid #ced4da;
            border-radius: 2px;
            font-size: 11px;
        }
        
        .alias-pin-selector {
            width: 100px;
            padding: 2px 4px;
            border: 1px solid #ced4da;
            border-radius: 2px;
            font-size: 11px;
        }
        
        .raw-container {
            display: flex;
            border: 1px solid #dee2e6;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .raw-line-numbers {
            width: 125px;
            background-color: #f8f9fa;
            border-right: 1px solid #dee2e6;
        }
        
        .raw-line-number {
            min-width: 50px;
            font-weight: bold;
            color: #6c757d;
            text-align: right;
            font-size: 11px;
            padding: 2px;
            padding-right: 10px;
            border-bottom: 1px solid #dee2e6;
            background-color: #f8f9fa;
            min-height: 22px;
            display: flex;
            align-items: center;
            justify-content: flex-end;
        }
        
        .raw-line-number:nth-child(even) {
            background-color: #ffffff;
        }
        
        .raw-textarea {
            flex: 1;
            min-height: 80px;
            padding: 2px;
            border: none;
            border-radius: 0;
            font-family: Arial, sans-serif;
            font-size: 12px;
            line-height: 27px;
            resize: none;
            overflow: hidden;
            background-color: #f8f9fa;
        }
        
        .operations-list {
            border: 1px solid #dee2e6;
            border-radius: 3px;
            overflow: hidden;
        }
        
        .operation-line {
            display: flex;
            align-items: center;
            gap: 5px;
            padding: 2px;
            border-bottom: 1px solid #dee2e6;
            background-color: #f8f9fa;
            min-height: 22px;
        }
        
        .operation-line:nth-child(even) {
            background-color: #ffffff;
        }
        
        .operation-line.comment-section {
            background-color: #616c77 !important;
            color: #ffffff;
        }
        
        .operation-line.comment-section .line-number {
            color: #ffffff;
        }
        
        .operation-line.comment-section .param-input {
            background-color: #495057;
            border-color: #6c757d;
            color: #ffffff;
        }
        
        /* State colors */
        .state-h {
            background-color: #dc3545 !important;
            color: #ffffff !important;
            border-color: #c82333 !important;
        }
        
        .state-l {
            background-color: #28a745 !important;
            color: #ffffff !important;
            border-color: #1e7e34 !important;
        }
        
        .state-z {
            background-color: #17a2b8 !important;
            color: #ffffff !important;
            border-color: #117a8b !important;
        }
        
        .state-p {
            background-color: #ffc107 !important;
            color: #212529 !important;
            border-color: #e0a800 !important;
        }
        
        .operation-line:last-child {
            border-bottom: none;
        }
        
        .line-number {
            min-width: 25px;
            font-weight: bold;
            color: #6c757d;
            text-align: center;
            font-size: 11px;
        }
        
        .operation-type {
            min-width: 100px;
        }
        
        .operation-type select {
            width: 100%;
            padding: 3px 5px;
            border: 1px solid #ced4da;
            border-radius: 3px;
            font-size: 11px;
        }
        
        /* Operation type colors */
        .operation-type select[data-operation="comment"] {
            background-color: #e9ecef;
            border-color: #adb5bd;
        }
        
        .operation-type select[data-operation="src"] {
            background-color: #d1ecf1;
            border-color: #17a2b8;
        }
        
        .operation-type select[data-operation="src_sig"] {
            background-color: #f0e6ff;
            border-color: #9c27b0;
        }
        
        .operation-type select[data-operation="io"] {
            background-color: #d4edda;
            border-color: #28a745;
        }
        
        .operation-type select[data-operation="iolevel"] {
            background-color: #cfe2ff;
            border-color: #0d6efd;
        }
        
        .operation-type select[data-operation="pd"] {
            background-color: #fff3cd;
            border-color: #ffc107;
        }
        
        .operation-type select[data-operation="i"] {
            background-color: #f8d7da;
            border-color: #dc3545;
        }
        
        .operation-type select[data-operation="v"] {
            background-color: #e2e3e5;
            border-color: #6c757d;
        }
        
        .operation-type select[data-operation="reset"] {
            background-color: #e2d9f3;
            border-color: #6f42c1;
        }
        
        .operation-type select[data-operation="scope"] {
            background-color: #ffeaa7;
            border-color: #fdcb6e;
        }
        
        .operation-type select[data-operation="check_min"] {
            background-color: #fd79a8;
            border-color: #e84393;
        }
        
        .operation-type select[data-operation="check_max"] {
            background-color: #fd79a8;
            border-color: #e84393;
        }
        
        .operation-type select[data-operation="check_avg"] {
            background-color: #fd79a8;
            border-color: #e84393;
        }
        
        .operation-type select[data-operation="check_freq"] {
            background-color: #fd79a8;
            border-color: #e84393;
        }
        
        .operation-params {
            display: flex;
            gap: 3px;
            flex: 1;
            align-items: center;
        }
        
        .param-input {
            padding: 3px 5px;
            border: 1px solid #ced4da;
            border-radius: 3px;
            font-size: 11px;
            min-width: 60px;
        }
        
        .param-select {
            padding: 3px 5px;
            border: 1px solid #ced4da;
            border-radius: 3px;
            font-size: 11px;
            min-width: 60px;
        }
        
        .repeat-checkbox {
            margin: 0;
            transform: scale(1.2);
        }
        
        .line-actions {
            display: flex;
            gap: 2px;
        }
        
        .btn-small {
            padding: 2px 6px;
            font-size: 10px;
            min-width: auto;
        }
        
        .add-operation {
            padding: 4px;
            text-align: center;
            background-color: #e9ecef;
            border-top: 1px solid #dee2e6;
        }
        
        .status {
            padding: 4px;
            border-radius: 3px;
            margin-top: 5px;
            display: none;
        }
        .status.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .status.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .status.warning {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeeba;
        }
        
        .test-result {
            font-weight: bold;
            margin-left: 5px;
        }
        
        .test-result.passed {
            color: #28a745;
        }
        
        .test-result.failed {
            color: #dc3545;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
        <input type="file" id="fileInput" class="file-input" accept="*" onchange="uploadFile(this)">
        
        <div id="status" class="status"></div>
        
        <div class="module-section">
            <div class="module-header">
                <div class="module-selector">
                    <select id="moduleSelector" onchange="selectModule(this.value)">
                        <option value="">Select module</option>
                    </select>
                    <div class="edit-mode-tabs">
                        <button id="editTab" class="btn btn-primary btn-small active" onclick="switchEditMode('edit')">Edit</button>
                        <button id="rawTab" class="btn btn-secondary btn-small" onclick="switchEditMode('raw')">Raw</button>
                    </div>
                </div>
                <div class="action-buttons">
                    <button class="btn btn-primary btn-small" onclick="downloadFile()">Download</button>
                    <button class="btn btn-warning btn-small" onclick="reloadFromDevice()">Reload</button>
                    <button class="btn btn-success btn-small" onclick="saveToDevice()">Save</button>
                    <button class="btn btn-secondary btn-small" onclick="document.getElementById('fileInput').click()">Upload</button>
                    <button class="btn btn-info btn-small" onclick="loadTestResults()">Refresh Results</button>
                </div>
            </div>
        </div>
        
        <div id="aliasesContainer" class="module-section" style="display: none;">
            <div class="aliases-header" onclick="toggleAliases()">
                <span class="aliases-toggle" id="aliasesToggle">▶</span>
                <span>Pin Aliases</span>
                <button class="btn btn-success btn-small" onclick="addAlias(); event.stopPropagation();">Add Alias</button>
            </div>
            <div id="aliasesContent" class="aliases-content">
                <div id="aliasesList" class="aliases-list">
                    <!-- Aliases for selected module will be shown here -->
                </div>
            </div>
        </div>
        
        <div id="operationsContainer" class="module-section" style="display: none;">
            <!-- Operations for selected module will be shown here -->
        </div>

    <script>
        let currentConfig = {
            modules: []
        };
        let selectedModuleIndex = -1;
        let selectedModuleFilename = null; // Currently selected module filename
        let modulesList = []; // List of all available modules
        let editMode = 'edit'; // 'edit' or 'raw'
        let testResults = null; // Store test results
        
        // Pin options for aliases
        const pinOptions = [
            'out A', 'out B', 'out C', 'out D',
            'in A', 'in B', 'in C', 'in D', 'in E', 'in F',
            'in pdA', 'in pdB', 'in pdC',
            'in zD', 'in zE', 'in zF',
            '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15'
        ];
        
        // Operation types
        const operationTypes = {
            'src': { name: 'Source', params: ['src_pin', 'voltage'] },
            'src_sig': { name: 'Source Signal', params: ['src_pin', 'frequency'] },
            'io': { name: 'IO', params: ['io_pin', 'state'] },
            'iolevel': { name: 'IO Level Check', params: ['io_pin', 'io_level'] },
            'pd': { name: 'Pulldown', params: ['pd_pin', 'pd_state'] },
            'i': { name: 'Check Current', params: ['rail', 'low', 'high'] },
            'v': { name: 'Check Voltage', params: ['pin', 'low', 'high'] },
            'scope': { name: 'Scope', params: ['pin', 'sample_freq', 'buffer_size'] },
            'min': { name: 'Check Min', params: ['pin', 'low', 'high'] },
            'max': { name: 'Check Max', params: ['pin', 'low', 'high'] },
            'avg': { name: 'Check Average', params: ['pin', 'low', 'high'] },
            'freq': { name: 'Check Frequency', params: ['pin', 'low', 'high'] },
            'amplitude': { name: 'Check Amplitude', params: ['pin', 'low', 'high'] },
            'delay': { name: 'Delay', params: ['timeout_ms'] },
            'reset': { name: 'Reset', params: [] },
            'comment': { name: 'Comment', params: [] }
        };
        
        // Helper function to replace original pin names with aliases for display
        const replaceWithAlias = (originalName, module) => {
            if (!module || !module.aliases) return originalName;
            
            // First try to find exact match
            let alias = module.aliases.find(a => a.pin === originalName);
            
            return alias ? alias.name : originalName;
        };

        // Helper function to get options with aliases
        const getOptionsWithAliases = (paramType, module) => {
            const baseOptions = paramOptions[paramType] || [];
            const optionsWithAliases = [];
            
            // Process each base option
            baseOptions.forEach(opt => {
                let displayValue = opt;
                if (paramType === 'src_pin') {
                    displayValue = `out ${opt}`;
                } else if (paramType === 'pin') {
                    displayValue = `in ${opt}`;
                }

                // Replace with alias if available
                displayValue = replaceWithAlias(displayValue, module);

                optionsWithAliases.push(displayValue);
            });
            
            return optionsWithAliases;
        };

        // Parameter options
        const paramOptions = {
            'pin': ['A', 'B', 'C', 'D', 'E', 'F', 'pdA', 'pdB', 'pdC', 'zD', 'zE', 'zF'],
            'src_pin': ['A', 'B', 'C', 'D'],
            'io_pin': ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12', '13', '14', '15'],
            'pd_pin': ['pdA', 'pdB', 'pdC'],
            'state': ['h', 'l', 'z'],
            'io_level': ['h', 'l'],
            'pd_state': ['p', 'z'],
            'rail': ['+12', '+5', '-12'],
            'sample_freq': ['1000', '5000', '10000', '50000', '100000'],
            'buffer_size': ['1024', '2048', '4096', '8192', '16384']
        };
        
        // Load current configuration on page load
        window.onload = function() {
            loadModulesList();
            
            // Add keyboard shortcut for mode switching
            document.addEventListener('keydown', function(event) {
                if (event.altKey && event.key === 't') {
                    event.preventDefault();
                    const newMode = editMode === 'edit' ? 'raw' : 'edit';
                    switchEditMode(newMode);
                }
            });
        };

        function loadModulesList() {
            console.log('[DEBUG] Loading modules list...');
            fetch('./modules')
                .then(response => {
                    console.log('[DEBUG] Modules list response status:', response.status);
                    return response.json();
                })
                .then(data => {
                    console.log('[DEBUG] Modules list received:', data);
                    modulesList = data;
                    populateModuleSelector();
                    loadCurrentModule();
                })
                .catch(error => {
                    console.error('[ERROR] Error loading modules list:', error);
                    showStatus('Failed to load modules list', 'error');
                });
        }

        function populateModuleSelector() {
            console.log('[DEBUG] Populating module selector with', modulesList.length, 'modules');
            const moduleSelector = document.getElementById('moduleSelector');
            moduleSelector.innerHTML = '<option value="">Select module</option>';
            
            modulesList.forEach(module => {
                console.log('[DEBUG] Adding module to selector:', module);
                const option = document.createElement('option');
                option.value = module.filename;
                option.textContent = `[${module.index}] ${module.name}`;
                moduleSelector.appendChild(option);
            });
        }

        function loadCurrentModule() {
            console.log('[DEBUG] Loading current module...');
            fetch('./current')
                .then(response => {
                    console.log('[DEBUG] Current module response status:', response.status);
                    return response.json();
                })
                .then(data => {
                    console.log('[DEBUG] Current module data:', data);
                    selectedModuleFilename = data.filename;
                    const moduleSelector = document.getElementById('moduleSelector');
                    moduleSelector.value = selectedModuleFilename;
                    console.log('[DEBUG] Selected module filename set to:', selectedModuleFilename);
                    loadModuleConfig(selectedModuleFilename);
                })
                .catch(error => {
                    console.error('[ERROR] Error loading current module:', error);
                    showStatus('Failed to load current module', 'error');
                });
        }

        function selectModule(filename) {
            console.log('[DEBUG] selectModule called with filename:', filename);
            if (!filename) return;
            selectedModuleFilename = filename;
            loadModuleConfig(filename);
        }

        function loadModuleConfig(filename) {
            console.log('[DEBUG] Loading module config for:', filename);
            fetch(`./config?module=${encodeURIComponent(filename)}`)
                .then(response => {
                    console.log('[DEBUG] Module config response status:', response.status);
                    return response.text();
                })
                .then(data => {
                    console.log('[DEBUG] Module config data received, length:', data.length);
                    console.log('[DEBUG] Module config content:', data);
                    parseConfig(data);
                    renderConfig();
                    loadTestResults();
                })
                .catch(error => {
                    console.error('[ERROR] Error loading module config:', error);
                    showStatus('Failed to load module configuration', 'error');
                });
        }


        function loadTestResults() {
            console.log('[DEBUG] Loading test results...');
            fetch('./results')
                .then(response => {
                    console.log('[DEBUG] Results response status:', response.status);
                    if (response.ok) {
                        return response.text();
                    } else {
                        console.log('[DEBUG] No test results available');
                        testResults = null;
                        return null;
                    }
                })
                .then(data => {
                    console.log('[DEBUG] Results data received, length:', data ? data.length : 0);
                    console.log('[DEBUG] Results raw data:', data);
                    if (data) {
                        parseTestResults(data);
                    }
                    console.log('[DEBUG] testResults after parsing:', testResults);
                    // Re-render to show results
                    if (selectedModuleIndex >= 0) {
                        showModuleOperations(selectedModuleIndex);
                    }
                })
                .catch(error => {
                    console.error('[ERROR] Error loading test results:', error);
                    testResults = null;
                });
        }

        function parseTestResults(data) {
            const lines = data.split('\n').filter(line => line.trim());
            console.log('[DEBUG] parseTestResults: total lines:', lines.length);
            if (lines.length === 0) {
                testResults = null;
                console.log('[DEBUG] parseTestResults: no lines, setting testResults to null');
                return;
            }

            const resultsModuleName = lines[0].trim();
            console.log('[DEBUG] Test results module name:', resultsModuleName);
            
            // Extract module name from selected filename (e.g., "01_mod_clk" -> "mod_clk")
            let selectedModuleName = '';
            if (selectedModuleFilename) {
                const underscorePos = selectedModuleFilename.indexOf('_');
                if (underscorePos > 0) {
                    selectedModuleName = selectedModuleFilename.substring(underscorePos + 1);
                }
            }
            console.log('[DEBUG] Selected module name:', selectedModuleName);
            console.log('[DEBUG] Comparing:', resultsModuleName, '===', selectedModuleName, '?', resultsModuleName === selectedModuleName);
            
            // Check if results match selected module
            if (selectedModuleName && resultsModuleName !== selectedModuleName) {
                console.log('[DEBUG] Test results are for different module. Ignoring.');
                testResults = null;
                showStatus(`Test results are for module "${resultsModuleName}", but selected module is "${selectedModuleName}"`, 'warning');
                return;
            }

            const results = [];

            for (let i = 1; i < lines.length; i++) {
                const line = lines[i].trim();
                const parts = line.split(' ');
                console.log('[DEBUG] Parsing result line', i, ':', line, '-> parts:', parts);
                if (parts.length >= 2) {
                    const passed = parts[0] === 'true';
                    const result = parseInt(parts[1]) || 0;
                    const executionTime = parts.length >= 3 ? parseInt(parts[2]) || 0 : 0;
                    const resultObj = { passed, result, executionTime };
                    console.log('[DEBUG] Result object:', resultObj);
                    results.push(resultObj);
                }
            }

            testResults = {
                moduleName: resultsModuleName,
                results: results
            };
            console.log('[DEBUG] Test results parsed successfully. Operations:', results.length);
            console.log('[DEBUG] Final testResults object:', testResults);
        }

        function parseConfig(text) {
            console.log('[DEBUG] parseConfig called, text length:', text.length);
            currentConfig.modules = [];
            const lines = text.split('\n');
            
            // Create a single module automatically (we don't have "module" line anymore)
            let currentModule = {
                name: selectedModuleFilename || 'unknown',
                id: 0,
                aliases: [],
                operations: []
            };
            currentConfig.modules.push(currentModule);
            console.log('[DEBUG] Created module:', currentModule.name);
            
            for (let line of lines) {
                line = line.trim();
                if (!line) continue;
                
                if (line.startsWith('# alias ') && currentModule) {
                    // Parse alias: "# alias <alias_name>=<pin_name>"
                    const aliasMatch = line.match(/^# alias\s+([^=]+)=(.*)$/);
                    if (aliasMatch) {
                        const aliasName = aliasMatch[1].trim();
                        const pinName = aliasMatch[2].trim();
                        currentModule.aliases.push({
                            name: aliasName,
                            pin: pinName
                        });
                    }
                } else if (line.startsWith('#') && currentModule) {
                    currentModule.operations.push({
                        type: 'comment',
                        text: line.substring(1).trim(),
                        repeat: false
                    });
                } else if (currentModule) {
                    const parts = line.split(' ');
                    if (parts.length > 0) {
                        const operation = {
                            type: parts[0],
                            repeat: /\+\s*$/.test(line),
                            params: parts.slice(1)
                        };
                        if (operation.repeat) {
                            // Remove all trailing '+' characters from the last parameter
                            operation.params[operation.params.length - 1] = operation.params[operation.params.length - 1].replace(/\+$/, '');
                        }
                        
                        // Convert original pin names back to display format with aliases
                        if (operation.params && operation.params.length > 0) {
                            operation.params = operation.params.map((param, paramIndex) => {
                                // Store original pin names without prefixes
                                return param;
                            });
                        }
                        
                        currentModule.operations.push(operation);
                    }
                }
            }
            console.log('[DEBUG] parseConfig finished. Modules:', currentConfig.modules.length);
            console.log('[DEBUG] Module data:', currentConfig.modules[0]);
            if (currentConfig.modules[0]) {
                console.log('[DEBUG] Aliases count:', currentConfig.modules[0].aliases.length);
                console.log('[DEBUG] Operations count:', currentConfig.modules[0].operations.length);
            }
        }

        function renderConfig() {
            console.log('[DEBUG] renderConfig called');
            // Auto-select the first (and only) module
            if (currentConfig.modules.length > 0) {
                console.log('[DEBUG] Rendering module 0');
                selectedModuleIndex = 0;
                showModuleOperations(0);
            } else {
                console.log('[DEBUG] No modules to render');
            }
        }
        
        function switchEditMode(mode) {
            editMode = mode;
            
            // Update tab buttons
            document.getElementById('editTab').className = `btn btn-primary btn-small ${mode === 'edit' ? 'active' : ''}`;
            document.getElementById('rawTab').className = `btn btn-secondary btn-small ${mode === 'raw' ? 'active' : ''}`;
            
            // Show appropriate content
            if (selectedModuleIndex >= 0 && selectedModuleIndex < currentConfig.modules.length) {
                showModuleOperations(selectedModuleIndex);
            }
        }
        
        function showModuleOperations(moduleIndex) {
            console.log('[DEBUG] showModuleOperations called with moduleIndex:', moduleIndex);
            const aliasesContainer = document.getElementById('aliasesContainer');
            const operationsContainer = document.getElementById('operationsContainer');
            const module = currentConfig.modules[moduleIndex];
            console.log('[DEBUG] Module to display:', module);
            
            // Show aliases
            aliasesContainer.style.display = 'block';
            aliasesContainer.innerHTML = `
                <div class="aliases-header" onclick="toggleAliases()">
                    <span class="aliases-toggle" id="aliasesToggle">▶</span>
                    <span>Pin Aliases</span>
                    <button class="btn btn-success btn-small" onclick="addAlias(); event.stopPropagation();">Add Alias</button>
                </div>
                <div id="aliasesContent" class="aliases-content">
                    <div id="aliasesList" class="aliases-list">
                        ${module.aliases.map((alias, aliasIndex) => renderAliasLine(moduleIndex, aliasIndex, alias)).join('')}
                    </div>
                </div>
            `;
            
            if (editMode === 'edit') {
                operationsContainer.innerHTML = `
                    <div class="operations-list">
                        ${module.operations.map((op, opIndex) => renderOperationLine(moduleIndex, opIndex, op)).join('')}
                        <div class="add-operation">
                            <button class="btn btn-primary btn-small" onclick="addOperation(${moduleIndex})">Add Operation</button>
                        </div>
                    </div>
                `;
            } else {
                // Raw mode - show textarea with module operations as text
                const moduleText = generateModuleText(module);
                const lines = moduleText.split('\n');
                const lineNumbers = lines.map((_, index) => index + 1).join('</div><div class="raw-line-number">');
                
                operationsContainer.innerHTML = `
                    <div class="raw-container">
                        <div class="raw-line-numbers">
                            <div class="raw-line-number">${lineNumbers}</div>
                        </div>
                        <textarea id="rawModuleText" class="raw-textarea" onchange="updateModuleFromRaw(${moduleIndex}, this.value)" oninput="autoResizeTextarea(this)">${moduleText}</textarea>
                    </div>
                `;
                
                // Auto-resize textarea after it's created
                setTimeout(() => {
                    const textarea = document.getElementById('rawModuleText');
                    if (textarea) {
                        autoResizeTextarea(textarea);
                    }
                }, 10);
            }
            operationsContainer.style.display = 'block';
            console.log('[DEBUG] showModuleOperations finished. Containers displayed.');
        }

        function renderAliasLine(moduleIndex, aliasIndex, alias) {
            const lineNumber = aliasIndex + 1;
            return `
                <div class="alias-line">
                    <div class="line-actions">
                        <button class="btn btn-danger btn-small" onclick="removeAlias(${moduleIndex}, ${aliasIndex})">Remove</button>
                        <button class="btn btn-primary btn-small" onclick="editAlias(${moduleIndex}, ${aliasIndex})">Edit</button>
                    </div>
                    <div class="alias-line-number">${lineNumber}</div>
                    <div class="alias-name-input">
                        <input type="text" value="${alias.name}" onchange="updateAliasName(${moduleIndex}, ${aliasIndex}, this.value)" placeholder="Alias name">
                    </div>
                    <div class="alias-pin-selector">
                        <select onchange="updateAliasPin(${moduleIndex}, ${aliasIndex}, this.value)">
                            <option value="">Select pin</option>
                            ${pinOptions.map(pin => {
                                const isSelected = alias.pin === pin;
                                return `<option value="${pin}" ${isSelected ? 'selected' : ''}>${pin}</option>`;
                            }).join('')}
                        </select>
                    </div>
                </div>
            `;
        }

        function addAlias() {
            if (selectedModuleIndex >= 0 && selectedModuleIndex < currentConfig.modules.length) {
                currentConfig.modules[selectedModuleIndex].aliases.push({
                    name: '',
                    pin: ''
                });
                showModuleOperations(selectedModuleIndex);
            }
        }

        function removeAlias(moduleIndex, aliasIndex) {
            if (moduleIndex >= 0 && moduleIndex < currentConfig.modules.length) {
                currentConfig.modules[moduleIndex].aliases.splice(aliasIndex, 1);
                showModuleOperations(moduleIndex);
            }
        }

        function editAlias(moduleIndex, aliasIndex) {
            if (moduleIndex >= 0 && moduleIndex < currentConfig.modules.length) {
                const alias = currentConfig.modules[moduleIndex].aliases[aliasIndex];
                const newName = prompt('Enter new alias name:', alias.name);
                if (newName !== null) {
                    alias.name = newName;
                    showModuleOperations(moduleIndex);
                }
            }
        }

        function updateAliasName(moduleIndex, aliasIndex, name) {
            if (moduleIndex >= 0 && moduleIndex < currentConfig.modules.length) {
                currentConfig.modules[moduleIndex].aliases[aliasIndex].name = name;
            }
        }

        function updateAliasPin(moduleIndex, aliasIndex, pin) {
            if (moduleIndex >= 0 && moduleIndex < currentConfig.modules.length) {
                currentConfig.modules[moduleIndex].aliases[aliasIndex].pin = pin;
            }
        }

        function renderOperationLine(moduleIndex, opIndex, operation) {
            const lineNumber = opIndex + 1;
            let paramsHtml = '';
            let isSectionComment = false;
            
            if (operation.type === 'comment') {
                isSectionComment = operation.text && operation.text.startsWith('#');
                paramsHtml = `<input type="text" class="param-input" value="${operation.text || ''}" onchange="updateOperationParam(${moduleIndex}, ${opIndex}, 0, this.value)" placeholder="Comment text">`;
            } else {
                const opType = operationTypes[operation.type];
                if (opType) {
                    paramsHtml = opType.params.map((param, paramIndex) => {
                        let value = operation.params[paramIndex] || '';
                        
                        // Special handling for frequency parameter - use text input
                        if (param === 'frequency') {
                            return `<input type="text" class="param-input" value="${value}" onchange="updateOperationParam(${moduleIndex}, ${opIndex}, ${paramIndex}, this.value)" placeholder="frequency (Hz)">`;
                        }
                        
                        // Special handling for sample_freq and buffer_size parameters - use text input
                        if (param === 'sample_freq' || param === 'buffer_size') {
                            return `<input type="text" class="param-input" value="${value}" onchange="updateOperationParam(${moduleIndex}, ${opIndex}, ${paramIndex}, this.value)" placeholder="${param}">`;
                        }
                        
                        // Special handling for timeout_ms parameter - always use text input
                        if (param === 'timeout_ms') {
                            return `<input type="text" class="param-input" value="${value}" onchange="updateOperationParam(${moduleIndex}, ${opIndex}, ${paramIndex}, this.value)" placeholder="timeout (ms)">`;
                        }
                        
                        if (paramOptions[param]) {
                            // Add state color classes for specific operations
                            let stateClass = '';
                            if ((operation.type === 'io' && param === 'state') || 
                                (operation.type === 'iolevel' && param === 'io_level') ||
                                (operation.type === 'pd' && param === 'pd_state')) {
                                if (value && ['h', 'l', 'z', 'p'].includes(value)) {
                                    stateClass = `state-${value}`;
                                }
                            }
                            
                            // Get options with aliases
                            const module = currentConfig.modules[moduleIndex];
                            const optionsWithAliases = getOptionsWithAliases(param, module);

                            let displayValue = value;
                            // Add prefix for display
                            if (operation.type === 'src' || operation.type === 'src_sig') {
                                displayValue = `out ${value}`;
                            } else if (
                                operation.type === 'v'
                                || operation.type === 'scope'
                                || operation.type === 'min'
                                || operation.type === 'max'
                                || operation.type === 'avg'
                                || operation.type === 'freq'
                                || operation.type === 'amplitude') {
                                displayValue = `in ${value}`;
                            }

                            displayValue = replaceWithAlias(displayValue, module);

                            return `<select class="param-select ${stateClass}" onchange="updateOperationParam(${moduleIndex}, ${opIndex}, ${paramIndex}, this.value)">
                                <option value="">Select ${param}</option>
                                ${optionsWithAliases.map((opt, i) => {
                                    const isSelected = opt === displayValue;
                                    return `<option value="${paramOptions[param][i]}" ${isSelected ? 'selected' : ''}>${opt}</option>`;
                                }).join('')}
                            </select>`;
                        } else {
                            return `<input type="text" class="param-input" value="${value}" onchange="updateOperationParam(${moduleIndex}, ${opIndex}, ${paramIndex}, this.value)" placeholder="${param}">`;
                        }
                    }).join('');
                }
            }

            return `
                <div class="operation-line${isSectionComment ? ' comment-section' : ''}">
                    <div class="line-actions">
                        <button class="btn btn-danger btn-small" onclick="removeOperation(${moduleIndex}, ${opIndex})">Remove</button>
                        <button class="btn btn-primary btn-small" onclick="insertOperation(${moduleIndex}, ${opIndex})">Insert</button>
                    </div>
                    <div class="line-number">${lineNumber}</div>
                    <div class="operation-type">
                        <select data-operation="${operation.type}" onchange="updateOperationType(${moduleIndex}, ${opIndex}, this.value)">
                            ${Object.keys(operationTypes).map(type => 
                                `<option value="${type}" ${type === operation.type ? 'selected' : ''}>${operationTypes[type].name}</option>`
                            ).join('')}
                        </select>
                    </div>
                    <div class="operation-params">
                        ${paramsHtml}
                        ${operation.type !== 'comment' ? `<input type="checkbox" class="repeat-checkbox" ${operation.repeat ? 'checked' : ''} onchange="updateOperationRepeat(${moduleIndex}, ${opIndex}, this.checked)">` : ''}
                        ${operation.type !== 'comment' ? '<span>Repeat</span>' : ''}
                        ${getTestResultHtml(moduleIndex, opIndex)}
                    </div>
                </div>
            `;
        }



        function addOperation(moduleIndex) {
            if (moduleIndex >= 0 && moduleIndex < currentConfig.modules.length) {
                currentConfig.modules[moduleIndex].operations.push({
                    type: 'comment',
                    text: '',
                    repeat: false
                });
                showModuleOperations(moduleIndex);
            }
        }

        function removeOperation(moduleIndex, opIndex) {
            if (moduleIndex >= 0 && moduleIndex < currentConfig.modules.length) {
                currentConfig.modules[moduleIndex].operations.splice(opIndex, 1);
                showModuleOperations(moduleIndex);
            }
        }

        function insertOperation(moduleIndex, opIndex) {
            if (moduleIndex >= 0 && moduleIndex < currentConfig.modules.length) {
                currentConfig.modules[moduleIndex].operations.splice(opIndex + 1, 0, {
                    type: 'comment',
                    text: '',
                    repeat: false
                });
                showModuleOperations(moduleIndex);
            }
        }

        function updateOperationType(moduleIndex, opIndex, type) {
            if (moduleIndex >= 0 && moduleIndex < currentConfig.modules.length) {
                const operation = currentConfig.modules[moduleIndex].operations[opIndex];
                operation.type = type;
                if (type === 'comment') {
                    operation.text = '';
                    operation.repeat = false;
                } else {
                    operation.params = [];
                    operation.repeat = false;
                }
                
                // Update the data-operation attribute for color
                const selectElement = event.target;
                selectElement.setAttribute('data-operation', type);
                
                showModuleOperations(moduleIndex);
            }
        }

        function updateOperationParam(moduleIndex, opIndex, paramIndex, value) {
            if (moduleIndex >= 0 && moduleIndex < currentConfig.modules.length) {
                const operation = currentConfig.modules[moduleIndex].operations[opIndex];
                if (operation.type === 'comment') {
                    operation.text = value;
                } else {
                    if (!operation.params) operation.params = [];
                    
                    // Remove prefixes for pin values when saving
                    let processedValue = value;
                    if (value && (value.startsWith('out ') || value.startsWith('in '))) {
                        processedValue = value.startsWith('out ') ? value.substring(4) : value.substring(3);
                    }
                    
                    operation.params[paramIndex] = processedValue;
                }
                
                // Re-render to update state colors
                showModuleOperations(moduleIndex);
            }
        }

        function updateOperationRepeat(moduleIndex, opIndex, repeat) {
            if (moduleIndex >= 0 && moduleIndex < currentConfig.modules.length) {
                currentConfig.modules[moduleIndex].operations[opIndex].repeat = repeat;
            }
        }

        function generateModuleText(module) {
            let text = '';
            
            // Add aliases first
            module.aliases.forEach(alias => {
                if (alias.name && alias.pin) {
                    text += `# alias ${alias.name}=${alias.pin}\n`;
                }
            });
            
            // Add operations
            module.operations.forEach(op => {
                if (op.type === 'comment') {
                    text += `# ${op.text}\n`;
                } else {
                    text += op.type;
                    if (op.params) {
                        // Process params - just use original pin names
                        const processedParams = op.params.map(param => {
                            return param;
                        });
                        
                        text += ' ' + processedParams.join(' ');
                    }
                    if (op.repeat) {
                        text += ' +';
                    }
                    text += '\n';
                }
            });
            // Remove trailing newline
            return text.replace(/\n$/, '');
        }
        
        function generateConfigText() {
            let text = '';
            currentConfig.modules.forEach(module => {
                text += generateModuleText(module);
                text += "\n";
            });
            return text.trim(); // Remove trailing newline
        }
        
        function autoResizeTextarea(textarea) {
            textarea.style.height = 'auto';
            const lineHeight = 27; // Exact line height in pixels
            const lines = textarea.value.split('\n').length;
            const minHeight = 80; // min-height from CSS
            const calculatedHeight = Math.max(minHeight, lines * lineHeight + 4); // +4 for padding
            textarea.style.height = calculatedHeight + 'px';
            
            // Update line numbers
            const lineNumbersContainer = textarea.parentElement.querySelector('.raw-line-numbers');
            if (lineNumbersContainer) {
                const lineNumbers = Array.from({length: lines}, (_, index) => index + 1).join('</div><div class="raw-line-number">');
                lineNumbersContainer.innerHTML = `<div class="raw-line-number">${lineNumbers}</div>`;
            }
        }
        
        function updateModuleFromRaw(moduleIndex, rawText) {
            if (moduleIndex >= 0 && moduleIndex < currentConfig.modules.length) {
                const module = currentConfig.modules[moduleIndex];
                module.aliases = [];
                module.operations = [];
                
                const lines = rawText.split('\n');
                for (let line of lines) {
                    line = line.trim();
                    if (!line) continue;
                    
                    if (line.startsWith('alias ')) {
                        // Parse alias: "alias <alias_name>=<pin_name>"
                        const aliasMatch = line.match(/^alias\s+([^=]+)=(.*)$/);
                        if (aliasMatch) {
                            const aliasName = aliasMatch[1].trim();
                            const pinName = aliasMatch[2].trim();
                            module.aliases.push({
                                name: aliasName,
                                pin: pinName
                            });
                        }
                    } else if (line.startsWith('# alias ')) {
                        // Parse alias: "# alias <alias_name>=<pin_name>"
                        const aliasMatch = line.match(/^# alias\s+([^=]+)=(.*)$/);
                        if (aliasMatch) {
                            const aliasName = aliasMatch[1].trim();
                            const pinName = aliasMatch[2].trim();
                            module.aliases.push({
                                name: aliasName,
                                pin: pinName
                            });
                        }
                    } else if (line.startsWith('#')) {
                        module.operations.push({
                            type: 'comment',
                            text: line.substring(1).trim(),
                            repeat: false
                        });
                    } else {
                        const parts = line.split(' ');
                        if (parts.length > 0) {
                            const operation = {
                                type: parts[0],
                                repeat: /\+\s*$/.test(line),
                                params: parts.slice(1)
                            };
                            if (operation.repeat) {
                                // Remove all trailing '+' characters from the last parameter
                                operation.params[operation.params.length - 1] = operation.params[operation.params.length - 1].replace(/\+$/, '');
                            }
                            module.operations.push(operation);
                        }
                    }
                }
            }
        }

        async function downloadFile() {
            try {
                const text = generateConfigText();
                const blob = new Blob([text], { type: 'application/octet-stream' });
                
                // Show save file dialog
                const handle = await window.showSaveFilePicker({
                    suggestedName: 'config',
                    types: [{
                        description: 'Configuration file',
                        accept: {
                            'application/octet-stream': ['.config']
                        }
                    }]
                });
                
                // Write the file
                const writable = await handle.createWritable();
                await writable.write(blob);
                await writable.close();
                
                showStatus('Configuration downloaded successfully!', 'success');
            } catch (error) {
                console.error('Download error:', error);
                // Fallback to old method if showSaveFilePicker is not supported
                const text = generateConfigText();
                const blob = new Blob([text], { type: 'application/octet-stream' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'config';
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
                showStatus('Configuration downloaded successfully!', 'success');
            }
        }

        function reloadFromDevice() {
            if (!selectedModuleFilename) {
                showStatus('No module selected', 'error');
                return;
            }
            loadModuleConfig(selectedModuleFilename);
            showStatus('Configuration reloaded from device', 'success');
        }

        function saveToDevice() {
            if (!selectedModuleFilename) {
                showStatus('No module selected', 'error');
                return;
            }
            
            const text = generateConfigText();
            fetch(`/config?module=${encodeURIComponent(selectedModuleFilename)}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'text/plain',
                },
                body: text
            })
            .then(response => {
                if (response.ok) {
                    showStatus('Configuration saved to device successfully!', 'success');
                } else {
                    throw new Error('Save failed');
                }
            })
            .catch(error => {
                console.error('Error:', error);
                showStatus('Failed to save configuration to device', 'error');
            });
        }

        function uploadFile(input) {
            const file = input.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const content = e.target.result;
                parseConfig(content);
                renderConfig();
                showStatus('Configuration loaded from file successfully!', 'success');
            };
            reader.readAsText(file);
            input.value = ''; // Reset input
        }

        function getTestResultHtml(moduleIndex, opIndex) {
            console.log('[DEBUG] getTestResultHtml called for moduleIndex:', moduleIndex, 'opIndex:', opIndex);
            console.log('[DEBUG] testResults:', testResults);
            
            if (!testResults || !testResults.results) {
                console.log('[DEBUG] No testResults or testResults.results');
                return '';
            }
            
            // Check if module name matches
            const module = currentConfig.modules[moduleIndex];
            console.log('[DEBUG] module:', module);
            console.log('[DEBUG] Comparing testResults.moduleName:', testResults.moduleName, 'with module.name:', module?.name);
            
            // Extract module name from filename if it contains underscore
            let moduleName = module?.name || '';
            if (moduleName.indexOf('_') > 0) {
                moduleName = moduleName.substring(moduleName.indexOf('_') + 1);
            }
            console.log('[DEBUG] Extracted module name:', moduleName);
            
            if (!module || testResults.moduleName !== moduleName) {
                console.log('[DEBUG] Module name mismatch or no module');
                return '';
            }
            
            // Count only non-comment operations up to this index
            let realOperationIndex = 0;
            for (let i = 0; i < opIndex; i++) {
                if (module.operations[i] && module.operations[i].type !== 'comment') {
                    realOperationIndex++;
                }
            }
            console.log('[DEBUG] realOperationIndex:', realOperationIndex);
            
            // Check if current operation is a comment
            if (module.operations[opIndex] && module.operations[opIndex].type === 'comment') {
                console.log('[DEBUG] Current operation is a comment, no result to show');
                return ''; // Don't show results for comments
            }
            
            // Get the result for this real operation
            if (realOperationIndex >= testResults.results.length) {
                console.log('[DEBUG] realOperationIndex', realOperationIndex, '>= testResults.results.length', testResults.results.length);
                return '';
            }
            
            const result = testResults.results[realOperationIndex];
            const resultClass = result.passed ? 'passed' : 'failed';
            console.log('[DEBUG] Returning result HTML for operation', opIndex, ':', result);
            
            return `<span class="test-result ${resultClass}">${result.result} (${result.executionTime}ms)</span>`;
        }

        function toggleAliases() {
            const toggle = document.getElementById('aliasesToggle');
            const content = document.getElementById('aliasesContent');
            
            if (content.classList.contains('expanded')) {
                content.classList.remove('expanded');
                toggle.classList.add('collapsed');
                toggle.textContent = '▶';
            } else {
                content.classList.add('expanded');
                toggle.classList.remove('collapsed');
                toggle.textContent = '▼';
            }
        }

        function showStatus(message, type) {
            const status = document.getElementById('status');
            status.textContent = message;
            status.className = 'status ' + type;
            status.style.display = 'block';
            
            setTimeout(() => {
                status.style.display = 'none';
            }, 5000);
        }
    </script>
</body>
</html> 